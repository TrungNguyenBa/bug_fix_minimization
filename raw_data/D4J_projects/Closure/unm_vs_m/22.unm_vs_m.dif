2c2
< index 722d225..b9aa412 100644
---
> index 722d2252..ee0fc6dd 100644
5,8c5,11
< @@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback
<      // Do not try to remove a block or an expr result. We already handle
<      // these cases when we visit the child, and the peephole passes will
<      // fix up the tree in more clever ways when these are removed.
---
> @@ -95,23 +95,58 @@ final class CheckSideEffects extends AbstractPostOrderCallback
>        return;
>      }
>  
> -    // Do not try to remove a block or an expr result. We already handle
> -    // these cases when we visit the child, and the peephole passes will
> -    // fix up the tree in more clever ways when these are removed.
10c13,14
< +    if (parent.getType() == Token.COMMA) {
---
> +    int pt = parent.getType();
> +    if (pt == Token.COMMA) {
12,13c16,25
< +      if (gramps.isCall() && parent == gramps.getFirstChild()) {
< +        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && "eval".equals(n.getNext().getString())) {
---
> +      if (gramps.isCall() &&
> +          parent == gramps.getFirstChild()) {
> +        // Semantically, a direct call to eval is different from an indirect
> +        // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first
> +        // expression to a comma to be a no-op if it's used to indirect
> +        // an eval.
> +        if (n == parent.getFirstChild() &&
> +            parent.getChildCount() == 2 &&
> +            n.getNext().isName() &&
> +            "eval".equals(n.getNext().getString())) {
15d26
< +        }
17,20c28,29
<  
<      // This no-op statement was there so that JSDoc information could
<      // be attached to the name. This check should not complain about it.
< -    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
---
> +      }
> +
26c35,36
< +          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
---
> +          if (ancestorType != Token.EXPR_RESULT &&
> +              ancestorType != Token.BLOCK)
32,33c42,44
< +    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
< +      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
---
> +    } else if (pt != Token.EXPR_RESULT && pt != Token.BLOCK) {
> +      if (pt == Token.FOR && parent.getChildCount() == 4 &&
> +          (n == parent.getFirstChild() ||
34a46,47
> +        // Fall through and look for warnings for the 1st and 3rd child
> +        // of a for.
36c49,50
<        return;
---
> +        return;  // it might be OK to not have a side-effect
> +      }
38d51
<      }
40,43c53,55
<      boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
<      boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
<      if (!isResultUsed &&
<          (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
---
> +    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
> +    if (isSimpleOp ||
> +        !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {
44a57,59
>          // This no-op statement was there so that JSDoc information could
>          // be attached to the name. This check should not complain about it.
> -    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
47,48c62,69
< +        return;
< +      }
---
> +        // we already reported the problem when we visited the child.
>          return;
>        }
>  
> -    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
> -    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
> -    if (!isResultUsed &&
> -        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
51a73,130
> diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java
> index 00e31e0e..5de1e6f7 100644
> --- a/src/com/google/javascript/jscomp/NodeUtil.java
> +++ b/src/com/google/javascript/jscomp/NodeUtil.java
> @@ -3111,7 +3111,6 @@ public final class NodeUtil {
>      // TODO(johnlenz): consider sharing some code with trySimpleUnusedResult.
>      Node parent = expr.getParent();
>      switch (parent.getType()) {
> -      case Token.BLOCK:
>        case Token.EXPR_RESULT:
>          return false;
>        case Token.HOOK:
> @@ -3120,21 +3119,6 @@ public final class NodeUtil {
>          return (expr == parent.getFirstChild())
>              ? true : isExpressionResultUsed(parent);
>        case Token.COMMA:
> -        Node gramps = parent.getParent();
> -        if (gramps.isCall() &&
> -            parent == gramps.getFirstChild()) {
> -          // Semantically, a direct call to eval is different from an indirect
> -          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first
> -          // expression to a comma to be a no-op if it's used to indirect
> -          // an eval. This we pretend that this is "used".
> -          if (expr == parent.getFirstChild() &&
> -              parent.getChildCount() == 2 &&
> -              expr.getNext().isName() &&
> -              "eval".equals(expr.getNext().getString())) {
> -            return true;
> -          }
> -        }
> -
>          return (expr == parent.getFirstChild())
>              ? false : isExpressionResultUsed(parent);
>        case Token.FOR:
> diff --git a/test/com/google/javascript/jscomp/CheckSideEffectsTest.java b/test/com/google/javascript/jscomp/CheckSideEffectsTest.java
> index e6ba2188..6c15df66 100644
> --- a/test/com/google/javascript/jscomp/CheckSideEffectsTest.java
> +++ b/test/com/google/javascript/jscomp/CheckSideEffectsTest.java
> @@ -68,10 +68,6 @@ public class CheckSideEffectsTest extends CompilerTestCase {
>           "var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)", e);
>      test("var a, b; a = (5, 6)",
>           "var a, b; a = (JSCOMPILER_PRESERVE(5), 6)", e);
> -    test("var a, b; a = (bar(), 6, 7)",
> -         "var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)", e);
> -    test("var a, b; a = (bar(), bar(), 7, 8)",
> -         "var a, b; a = (bar(), bar(), JSCOMPILER_PRESERVE(7), 8)", e);
>      test("var a, b; a = (b = 7, 6)", ok);
>      test("function x(){}\nfunction f(a, b){}\nf(1,(x(), 2));", ok);
>      test("function x(){}\nfunction f(a, b){}\nf(1,(2, 3));",
> @@ -87,8 +83,6 @@ public class CheckSideEffectsTest extends CompilerTestCase {
>           "for(JSCOMPILER_PRESERVE(void 0); true; foo()) { bar() }", e);
>      test("for(foo(); true; void 0) { bar() }",
>           "for(foo(); true; JSCOMPILER_PRESERVE(void 0)) { bar() }", e);
> -    test("for(foo(); true; (1, bar())) { bar() }",
> -         "for(foo(); true; (JSCOMPILER_PRESERVE(1), bar())) { bar() }", e);
>  
>      test("for(foo in bar) { foo() }", ok);
>      test("for (i = 0; el = el.previousSibling; i++) {}", ok);
