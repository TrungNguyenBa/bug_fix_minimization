2c2
< index c46ee7d..a77221a 100644
---
> index c46ee7d9..fca42f1a 100644
23c23,44
< @@ -372,12 +372,6 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
---
> @@ -348,18 +348,13 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
>          return false;
>        }
>  
> -      // We give up inlining stuff with R-Value that has:
> -      // 1) GETPROP, GETELEM,
> -      // 2) anything that creates a new object.
> -      // 3) a direct reference to a catch expression.
> +      // We give up inlining stuff with R-Value that has GETPROP, GETELEM,
> +      // or anything that creates a new object.
>        // Example:
>        // var x = a.b.c; j.c = 1; print(x);
>        // Inlining print(a.b.c) is not safe consider j and be alias to a.b.
>        // TODO(user): We could get more accuracy by looking more in-detail
>        // what j is and what x is trying to into to.
> -      // TODO(johnlenz): rework catch expression handling when we
> -      // have lexical scope support so catch expressions don't
> -      // need to be special cased.
>        if (NodeUtil.has(def.getLastChild(),
>            new Predicate<Node>() {
>                @Override
> @@ -372,12 +367,6 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
35a57,112
> diff --git a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java
> index 09caf56c..6e5c4004 100644
> --- a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java
> +++ b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java
> @@ -142,51 +142,6 @@ public class FlowSensitiveInlineVariablesTest extends CompilerTestCase  {
>      noInline("var y = noSFX(); do { var z = y.foo(); } while (true);");
>    }
>  
> -  public void testDoNotInlineCatchExpression1() {
> -    noInline(
> -        "var a;\n" +
> -        "try {\n" +
> -        "  throw Error(\"\");\n" +
> -        "}catch(err) {" +
> -        "   a = err;\n" +
> -        "}\n" +
> -        "return a.stack\n");
> -  }
> -
> -  public void testDoNotInlineCatchExpression1a() {
> -    noInline(
> -        "var a;\n" +
> -        "try {\n" +
> -        "  throw Error(\"\");\n" +
> -        "}catch(err) {" +
> -        "   a = err + 1;\n" +
> -        "}\n" +
> -        "return a.stack\n");
> -  }
> -
> -  public void testDoNotInlineCatchExpression2() {
> -    noInline(
> -        "var a;\n" +
> -        "try {\n" +
> -        "  if (x) {throw Error(\"\");}\n" +
> -        "}catch(err) {" +
> -        "   a = err;\n" +
> -        "}\n" +
> -        "return a.stack\n");
> -  }
> -
> -  public void testDoNotInlineCatchExpression3() {
> -    noInline(
> -        "var a;\n" +
> -        "try {\n" +
> -        "  throw Error(\"\");\n" +
> -        "} catch(err) {" +
> -        "  err = x;\n" +
> -        "  a = err;\n" +
> -        "}\n" +
> -        "return a.stack\n");
> -  }
> -
>    public void testDefinitionAfterUse() {
>      inline("var x = 0; print(x); x = 1", "var x; print(0); x = 1");
>    }
