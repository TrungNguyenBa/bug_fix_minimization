0a1,14
> diff --git a/src/com/google/javascript/jscomp/CompilerOptions.java b/src/com/google/javascript/jscomp/CompilerOptions.java
> index 233ab472..4fecfbed 100644
> --- a/src/com/google/javascript/jscomp/CompilerOptions.java
> +++ b/src/com/google/javascript/jscomp/CompilerOptions.java
> @@ -1150,8 +1150,8 @@ public class CompilerOptions implements Serializable, Cloneable {
>  
>    /**
>     * Set the variable removal policy for the compiler.
> +   * @deprecated
>     */
> -  @Deprecated
>    public void setRemoveUnusedVariable(Reach reach) {
>      setRemoveUnusedVariables(reach);
>    }
2c16
< index f9943a1..92d8715 100644
---
> index f9943a13..215f0360 100644
5,9c19,20
< @@ -417,7 +417,6 @@ final class TypedScopeCreator implements ScopeCreator {
<       * For more information, see
<       * http://code.google.com/p/closure-compiler/issues/detail?id=314
<       */
< -    private List<Node> lentObjectLiterals = null;
---
> @@ -408,18 +408,6 @@ final class TypedScopeCreator implements ScopeCreator {
>      private final List<Node> nonExternFunctions = Lists.newArrayList();
11a23,34
> -     * Object literals with a @lends annotation aren't analyzed until we
> -     * reach the root of the statement they're defined in.
> -     *
> -     * This ensures that if there are any @lends annotations on the object
> -     * literals, the type on the @lends annotation resolves correctly.
> -     *
> -     * For more information, see
> -     * http://code.google.com/p/closure-compiler/issues/detail?id=314
> -     */
> -    private List<Node> lentObjectLiterals = null;
> -
> -    /**
13c36,38
< @@ -545,13 +544,6 @@ final class TypedScopeCreator implements ScopeCreator {
---
>       *
>       * If at the end of traversal, we still don't have types for these
> @@ -543,15 +531,6 @@ final class TypedScopeCreator implements ScopeCreator {
15,16c40,43
<  
<        // Analyze any @lends object literals in this statement.
---
>            break;
>        }
> -
> -      // Analyze any @lends object literals in this statement.
27c54
< @@ -585,16 +577,7 @@ final class TypedScopeCreator implements ScopeCreator {
---
> @@ -585,16 +564,7 @@ final class TypedScopeCreator implements ScopeCreator {
39c66
<              defineObjectLiteral(n);
---
> -            defineObjectLiteral(n);
40a68
> +          defineObjectLiteral(t, n);
43a72,158
> @@ -602,7 +572,7 @@ final class TypedScopeCreator implements ScopeCreator {
>        }
>      }
>  
> -    private void defineObjectLiteral(Node objectLit) {
> +    private void defineObjectLiteral(NodeTraversal t, Node objectLit) {
>        // Handle the @lends annotation.
>        JSType type = null;
>        JSDocInfo info = objectLit.getJSDocInfo();
> @@ -646,7 +616,7 @@ final class TypedScopeCreator implements ScopeCreator {
>  
>        // If this is an enum, the properties were already taken care of above.
>        processObjectLitProperties(
> -          objectLit, ObjectType.cast(objectLit.getJSType()), !createdEnumType);
> +          t, objectLit, ObjectType.cast(objectLit.getJSType()), !createdEnumType);
>      }
>  
>      /**
> @@ -658,7 +628,7 @@ final class TypedScopeCreator implements ScopeCreator {
>       *     well. If false, the caller should take crae of this.
>       */
>      void processObjectLitProperties(
> -        Node objLit, ObjectType objLitType,
> +        NodeTraversal t, Node objLit, ObjectType objLitType,
>          boolean declareOnOwner) {
>        for (Node keyNode = objLit.getFirstChild(); keyNode != null;
>             keyNode = keyNode.getNext()) {
> @@ -666,7 +636,7 @@ final class TypedScopeCreator implements ScopeCreator {
>          String memberName = NodeUtil.getObjectLitKeyName(keyNode);
>          JSDocInfo info = keyNode.getJSDocInfo();
>          JSType valueType =
> -            getDeclaredType(keyNode.getSourceFileName(), info, keyNode, value);
> +            getDeclaredType(t.getSourceName(), info, keyNode, value);
>          JSType keyType =  objLitType.isEnumType() ?
>              objLitType.toMaybeEnumType().getElementsType() :
>              NodeUtil.getObjectLitKeyTypeFromValueType(keyNode, valueType);
> @@ -683,7 +653,7 @@ final class TypedScopeCreator implements ScopeCreator {
>  
>          if (keyType != null && objLitType != null && declareOnOwner) {
>            // Declare this property on its object literal.
> -          boolean isExtern = keyNode.isFromExterns();
> +          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
>            objLitType.defineDeclaredProperty(memberName, keyType, keyNode);
>          }
>        }
> diff --git a/test/com/google/javascript/jscomp/TypeCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckTest.java
> index 11613655..bae183d8 100644
> --- a/test/com/google/javascript/jscomp/TypeCheckTest.java
> +++ b/test/com/google/javascript/jscomp/TypeCheckTest.java
> @@ -8777,37 +8777,6 @@ public class TypeCheckTest extends CompilerTypeTestCase {
>              "Bad type annotation. missing object name in @lends tag"));
>    }
>  
> -  public void testLends10() throws Exception {
> -    testTypes(
> -        "function defineClass(x) { return function() {}; } " +
> -        "/** @constructor */" +
> -        "var Foo = defineClass(" +
> -        "    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));" +
> -        "/** @return {string} */ function f() { return (new Foo()).bar; }",
> -        "inconsistent return type\n" +
> -        "found   : number\n" +
> -        "required: string");
> -  }
> -
> -  public void testLends11() throws Exception {
> -    testTypes(
> -        "function defineClass(x, y) { return function() {}; } " +
> -        "/** @constructor */" +
> -        "var Foo = function() {};" +
> -        "/** @return {*} */ Foo.prototype.bar = function() { return 3; };" +
> -        "/**\n" +
> -        " * @constructor\n" +
> -        " * @extends {Foo}\n" +
> -        " */\n" +
> -        "var SubFoo = defineClass(Foo, " +
> -        "    /** @lends {SubFoo.prototype} */ ({\n" +
> -        "      /** @return {number} */ bar: function() { return 3; }}));" +
> -        "/** @return {string} */ function f() { return (new SubFoo()).bar(); }",
> -        "inconsistent return type\n" +
> -        "found   : number\n" +
> -        "required: string");
> -  }
> -
>    public void testDeclaredNativeTypeEquality() throws Exception {
>      Node n = parseAndTypeCheck("/** @constructor */ function Object() {};");
>      assertEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),
