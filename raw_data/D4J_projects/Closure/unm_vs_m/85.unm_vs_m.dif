2c2
< index e6d4320..c2150b1 100644
---
> index e6d4320a..5d705d13 100644
5c5
< @@ -150,7 +150,20 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback
---
> @@ -150,7 +150,27 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback
8a9,12
> +    // If the parent is null, this mean whatever node it was there is now
> +    // useless and it has been removed by other logics in this pass. That node
> +    // while no longer exists in the AST, is still in the CFG because we
> +    // never update the graph as nodes are removed.
12c16,17
< +        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());
---
> +        return tryRemoveUnconditionalBranching(
> +          outEdges.get(0).getDestination().getValue());
14a20
> +
21c27,28
< +          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));
---
> +          return tryRemoveUnconditionalBranching(
> +            ControlFlowAnalysis.computeFollowNode(n));
26c33,38
< @@ -167,7 +180,7 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback
---
> @@ -163,11 +183,12 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback
>          // branches to that same node. It is safe to remove it.
>          List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();
>          if (outEdges.size() == 1 &&
> +
>              // If there is a next node, there is no chance this jump is useless.
28c40
<  
---
> -
31c43,44
< +          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));
---
> +          Node fallThrough = tryRemoveUnconditionalBranching(
> +            ControlFlowAnalysis.computeFollowNode(n));
35c48,50
< @@ -180,13 +193,6 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback
---
> @@ -178,18 +199,6 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback
>      return n;
>    }
37,38c52,53
<    private Node computeFollowing(Node n) {
<      Node next = ControlFlowAnalysis.computeFollowNode(n);
---
> -  private Node computeFollowing(Node n) {
> -    Node next = ControlFlowAnalysis.computeFollowNode(n);
46,47c61,71
<      return next;
<    }
---
> -    return next;
> -  }
> -
>    private void removeDeadExprStatementSafely(Node n) {
>      Node parent = n.getParent();
>      if (n.getType() == Token.EMPTY ||
> diff --git a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java
> index f79beebb..68079253 100644
> --- a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java
> +++ b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java
> @@ -233,42 +233,11 @@ public class UnreachableCodeEliminationTest extends CompilerTestCase {
48a73,113
>    public void testCascadedRemovalOfUnlessUnconditonalJumps() {
>      test("switch (a) { case 'a': break; case 'b': break; case 'c': break }",
> -         "switch (a) { case 'a': break; case 'b': case 'c': }");
> -    // Only one break removed per pass.
> -    test("switch (a) { case 'a': break; case 'b': case 'c': }",
>           "switch (a) { case 'a': case 'b': case 'c': }");
> -
>      test("function foo() {" +
>           "  switch (a) { case 'a':return; case 'b':return; case 'c':return }}",
> -      "function foo() { switch (a) { case 'a':return; case 'b': case 'c': }}");
> -    test("function foo() {" +
> -      "  switch (a) { case 'a':return; case 'b': case 'c': }}",
>           "function foo() { switch (a) { case 'a': case 'b': case 'c': }}");
> -
>      testSame("function foo() {" +
>               "switch (a) { case 'a':return 2; case 'b':return 1}}");
>    }
> -
> -  public void testIssue311() {
> -    test("function a(b) {\n" +
> -         "  switch (b.v) {\n" +
> -         "    case 'SWITCH':\n" +
> -         "      if (b.i >= 0) {\n" +
> -         "        return b.o;\n" +
> -         "      } else {\n" +
> -         "        return;\n" +
> -         "      }\n" +
> -         "      break;\n" +
> -         "  }\n" +
> -         "}",
> -         "function a(b) {\n" +
> -         "  switch (b.v) {\n" +
> -         "    case 'SWITCH':\n" +
> -         "      if (b.i >= 0) {\n" +
> -         "        return b.o;\n" +
> -         "      } else {\n" +
> -         "      }\n" +
> -         "  }\n" +
> -         "}");
> -  }
>  }
