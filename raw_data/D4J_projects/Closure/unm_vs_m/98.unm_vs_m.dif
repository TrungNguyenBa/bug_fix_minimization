0a1,47
> diff --git a/lib/protobuf_deploy.jar b/lib/protobuf_deploy.jar
> index 0ba2e33b..6d3c117b 100755
> Binary files a/lib/protobuf_deploy.jar and b/lib/protobuf_deploy.jar differ
> diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java
> index b29886e0..0e3c9864 100644
> --- a/src/com/google/javascript/jscomp/CollapseProperties.java
> +++ b/src/com/google/javascript/jscomp/CollapseProperties.java
> @@ -214,7 +214,7 @@ class CollapseProperties implements CompilerPass {
>            collector.getReferenceCollection(aliasVar);
>        if (aliasRefs.isWellDefined()
>            && aliasRefs.firstReferenceIsAssigningDeclaration()
> -          && aliasRefs.isAssignedOnceInLifetime()) {
> +          && aliasRefs.isAssignedOnce()) {
>          // The alias is well-formed, so do the inlining now.
>          int size = aliasRefs.references.size();
>          Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);
> diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java
> index c14c8456..b9538c35 100644
> --- a/src/com/google/javascript/jscomp/InlineVariables.java
> +++ b/src/com/google/javascript/jscomp/InlineVariables.java
> @@ -178,7 +178,7 @@ class InlineVariables implements CompilerPass {
>            // another pass that handles unused variables much more elegantly.
>            if (referenceInfo != null && referenceInfo.references.size() >= 2 &&
>                referenceInfo.isWellDefined() &&
> -              referenceInfo.isAssignedOnceInLifetime()) {
> +              referenceInfo.isAssignedOnce()) {
>              Reference init = referenceInfo.getInitializingReference();
>              Node value = init.getAssignedValue();
>              if (value != null && value.getType() == Token.NAME) {
> @@ -270,7 +270,7 @@ class InlineVariables implements CompilerPass {
>        // reference data is out of sync. We're better off just waiting for
>        // the next pass.)
>        if (!staleVars.contains(v) && referenceInfo.isWellDefined() &&
> -          referenceInfo.isAssignedOnceInLifetime()) {
> +          referenceInfo.isAssignedOnce()) {
>          List<Reference> refs = referenceInfo.references;
>          for (int i = 1 /* start from a read */; i < refs.size(); i++) {
>            Node nameNode = refs.get(i).getNameNode();
> @@ -425,7 +425,7 @@ class InlineVariables implements CompilerPass {
>          return false;
>        }
>  
> -      if (!refInfo.isAssignedOnceInLifetime()) {
> +      if (!refInfo.isAssignedOnce()) {
>          return false;
>        }
>  
2c49
< index da4ed3e..f053321 100644
---
> index da4ed3e0..1e4b0ae9 100644
5c52
< @@ -358,14 +358,6 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {
---
> @@ -348,46 +348,22 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {
8c55,66
<        // Make sure this assignment is not in a loop.
---
>      /**
> -     * @return Whether the variable is only assigned a value once for its
> -     *     lifetime.
> +     * @return Whether the variable is only assigned a value once.
>       */
> -    boolean isAssignedOnceInLifetime() {
> -      Reference ref = getOneAndOnlyAssignment();
> -      if (ref == null) {
> -        return false;
> -      }
> -
> -      // Make sure this assignment is not in a loop.
17,18c75,102
<  
<        return true;
---
> -
> -      return true;
> -    }
> -
> -    /**
> -     * @return The one and only assignment. Returns if there are 0 or 2+
> -     *    assignments.
> -     */
> -    private Reference getOneAndOnlyAssignment() {
> -      Reference assignment = null;
> +    boolean isAssignedOnce() {
> +      boolean assigned = false;
>        int size = references.size();
>        for (int i = 0; i < size; i++) {
>          Reference ref = references.get(i);
>          if (ref.isLvalue() || ref.isInitializingDeclaration()) {
> -          if (assignment == null) {
> -            assignment = ref;
> +          if (!assigned) {
> +            assigned = true;
>            } else {
> -            return null;
> +            return false;
>            }
>          }
>        }
> -      return assignment;
> +      return assigned;
20,24d103
< @@ -550,12 +542,10 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {
<      /**
<       * Whether this block denotes a function scope.
<       */
< -    private final boolean isFunction;
27,29c106,107
<       * Whether this block denotes a loop.
<       */
< -    private final boolean isLoop;
---
> @@ -548,16 +524,6 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {
>      private final boolean isHoisted;
31a110,119
> -     * Whether this block denotes a function scope.
> -     */
> -    private final boolean isFunction;
> -
> -    /**
> -     * Whether this block denotes a loop.
> -     */
> -    private final boolean isLoop;
> -
> -    /**
33c121,124
< @@ -568,16 +558,7 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {
---
>       * @param parent The containing block.
>       * @param root The root node of the block.
> @@ -567,17 +533,6 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {
>  
36c127
<  
---
> -
38c129
<  
---
> -
49a141,183
> diff --git a/test/com/google/javascript/jscomp/InlineVariablesTest.java b/test/com/google/javascript/jscomp/InlineVariablesTest.java
> index 7c2d91e9..f4742731 100644
> --- a/test/com/google/javascript/jscomp/InlineVariablesTest.java
> +++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java
> @@ -593,38 +593,6 @@ public class InlineVariablesTest extends CompilerTestCase {
>           "var x; x = this.foo(); this.bar(); function f() { this.baz(x); }");
>    }
>  
> -  public void testInlineAliasesInLoop() {
> -    test(
> -        "function f() { " +
> -        "  var x = extern();" +
> -        "  for (var i = 0; i < 5; i++) {" +
> -        "    (function() {" +
> -        "       var y = x; window.setTimeout(function() { extern(y); }, 0);" +
> -        "     })();" +
> -        "  }" +
> -        "}",
> -        "function f() { " +
> -        "  var x = extern();" +
> -        "  for (var i = 0; i < 5; i++) {" +
> -        "    (function() {" +
> -        "       window.setTimeout(function() { extern(x); }, 0);" +
> -        "     })();" +
> -        "  }" +
> -        "}");
> -  }
> -
> -  public void testNoInlineAliasesInLoop() {
> -    testSame(
> -        "function f() { " +
> -        "  for (var i = 0; i < 5; i++) {" +
> -        "    var x = extern();" +
> -        "    (function() {" +
> -        "       var y = x; window.setTimeout(function() { extern(y); }, 0);" +
> -        "     })();" +
> -        "  }" +
> -        "}");
> -  }
> -
>    public void testNoInlineAliases1() {
>      testSame(
>          "var x = this.foo(); this.bar(); var y = x; x = 3; this.baz(y);");
