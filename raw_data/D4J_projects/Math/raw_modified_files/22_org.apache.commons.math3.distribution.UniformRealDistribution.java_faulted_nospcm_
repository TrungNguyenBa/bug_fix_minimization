package org.apache.commons.math3.distribution;
import org.apache.commons.math3.exception.NumberIsTooLargeException;
import org.apache.commons.math3.exception.util.LocalizedFormats;
import org.apache.commons.math3.random.RandomGenerator;
import org.apache.commons.math3.random.Well19937c;
public class UniformRealDistribution extends AbstractRealDistribution {
public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
private static final long serialVersionUID = 20120109L;
private final double lower;
private final double upper;
private final double solverAbsoluteAccuracy;
public UniformRealDistribution() {
this(0, 1);
}
public UniformRealDistribution(double lower, double upper)
throws NumberIsTooLargeException {
this(lower, upper, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
}
public UniformRealDistribution(double lower, double upper, double inverseCumAccuracy)
throws NumberIsTooLargeException {
this(new  Well19937c(), lower, upper, inverseCumAccuracy);
}
public UniformRealDistribution(RandomGenerator rng,
double lower,
double upper,
double inverseCumAccuracy)
throws NumberIsTooLargeException {
super(rng);
if (lower >= upper) {
throw new NumberIsTooLargeException(
LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,
lower, upper, false);
}
this.lower = lower;
this.upper = upper;
solverAbsoluteAccuracy = inverseCumAccuracy;
}
public double density(double x) {
if (x < lower || x > upper) {
return 0.0;
}
return 1 / (upper - lower);
}
public double cumulativeProbability(double x)  {
if (x <= lower) {
return 0;
}
if (x >= upper) {
return 1;
}
return (x - lower) / (upper - lower);
}
@Override
protected double getSolverAbsoluteAccuracy() {
return solverAbsoluteAccuracy;
}
public double getNumericalMean() {
return 0.5 * (lower + upper);
}
public double getNumericalVariance() {
double ul = upper - lower;
return ul * ul / 12;
}
public double getSupportLowerBound() {
return lower;
}
public double getSupportUpperBound() {
return upper;
}
public boolean isSupportLowerBoundInclusive() {
return true;
}
public boolean isSupportUpperBoundInclusive() {
return false;
}
public boolean isSupportConnected() {
return true;
}
@Override
public double sample()  {
final double u = random.nextDouble();
return u * upper + (1 - u) * lower;
}
}
