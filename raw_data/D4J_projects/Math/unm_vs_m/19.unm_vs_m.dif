2c2
< index f6a4f28..51d1c64 100644
---
> index f6a4f2820..b54cb3744 100644
5c5,30
< @@ -537,19 +537,6 @@ public class CMAESOptimizer
---
> @@ -24,8 +24,8 @@ import java.util.List;
>  import org.apache.commons.math3.analysis.MultivariateFunction;
>  import org.apache.commons.math3.exception.DimensionMismatchException;
>  import org.apache.commons.math3.exception.MathUnsupportedOperationException;
> +import org.apache.commons.math3.exception.MathIllegalStateException;
>  import org.apache.commons.math3.exception.NotPositiveException;
> -import org.apache.commons.math3.exception.NumberIsTooLargeException;
>  import org.apache.commons.math3.exception.OutOfRangeException;
>  import org.apache.commons.math3.exception.TooManyEvaluationsException;
>  import org.apache.commons.math3.exception.util.LocalizedFormats;
> @@ -78,12 +78,6 @@ import org.apache.commons.math3.util.MathArrays;
>   *  <li><a href="http://en.wikipedia.org/wiki/CMA-ES">Wikipedia</a></li>
>   * </ul>
>   *
> - * When simple constraints (boundaries) are used, care must be taken that the
> - * difference between the upper and lower bounds does not overflow; should it
> - * be the case, a {@link NumberIsTooLargeException} will be thrown by the
> - * {@link BaseAbstractMultivariateSimpleBoundsOptimizer#optimize(int,
> - * MultivariateFunction,GoalType,double[],double[],double[]) optimize} method.
> - *
>   * @version $Id$
>   * @since 3.0
>   */
> @@ -535,21 +529,6 @@ public class CMAESOptimizer
>                  boundaries = new double[2][];
>                  boundaries[0] = lB;
7,8c32,33
<  
<                  // Abort early if the normalization will overflow (cf. "encode" method).
---
> -
> -                // Abort early if the normalization will overflow (cf. "encode" method).
24a50,111
> diff --git a/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java b/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java
> index c17f72d16..38818798c 100644
> --- a/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java
> +++ b/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java
> @@ -26,13 +26,11 @@ import org.apache.commons.math3.exception.NumberIsTooLargeException;
>  import org.apache.commons.math3.exception.NumberIsTooSmallException;
>  import org.apache.commons.math3.exception.DimensionMismatchException;
>  import org.apache.commons.math3.exception.MathUnsupportedOperationException;
> -import org.apache.commons.math3.exception.MathIllegalStateException;
>  import org.apache.commons.math3.exception.NotPositiveException;
>  import org.apache.commons.math3.exception.OutOfRangeException;
>  import org.apache.commons.math3.optimization.GoalType;
>  import org.apache.commons.math3.optimization.PointValuePair;
>  import org.apache.commons.math3.random.MersenneTwister;
> -import org.apache.commons.math3.util.FastMath;
>  import org.junit.Assert;
>  import org.junit.Test;
>  import org.junit.runner.RunWith;
> @@ -378,6 +376,7 @@ public class CMAESOptimizerTest {
>      public void testMath864() {
>          final CMAESOptimizer optimizer = new CMAESOptimizer();
>          final MultivariateFunction fitnessFunction = new MultivariateFunction() {
> +                @Override
>                  public double value(double[] parameters) {
>                      final double target = 1;
>                      final double error = target - parameters[0];
> @@ -395,35 +394,6 @@ public class CMAESOptimizerTest {
>      }
>  
>      /**
> -     * Cf. MATH-865
> -     */
> -    @Test(expected=NumberIsTooLargeException.class)
> -    public void testBoundaryRangeTooLarge() {
> -        final CMAESOptimizer optimizer = new CMAESOptimizer();
> -        final MultivariateFunction fitnessFunction = new MultivariateFunction() {
> -                public double value(double[] parameters) {
> -                    if (Double.isNaN(parameters[0])) {
> -                        throw new MathIllegalStateException();
> -                    }
> -                    final double target = 1;
> -                    final double error = target - parameters[0];
> -                    return error * error;
> -                }
> -            };
> -
> -        final double[] start = { 0 };
> -
> -        // The difference between upper and lower bounds is used to used
> -        // normalize the variables: In case of overflow, NaN is produced.
> -        final double max = Double.MAX_VALUE / 2;
> -        final double tooLarge = FastMath.nextUp(max);
> -        final double[] lower = { -tooLarge };
> -        final double[] upper = { tooLarge };
> -        final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,
> -                                                   start, lower, upper).getPoint();
> -    }
> -
> -    /**
>       * @param func Function to optimize.
>       * @param startPoint Starting point.
>       * @param inSigma Individual input sigma.
