2c2
< index b3a23a1..e258c68 100644
---
> index b3a23a1d4..fde7172e3 100644
5,8c5,27
< @@ -182,19 +182,10 @@ public abstract class BaseSecantSolver
<                  case PEGASUS:
<                      f0 *= f1 / (f1 + fx);
<                      break;
---
> @@ -169,37 +169,25 @@ public abstract class BaseSecantSolver
>  
>              // Update the bounds with the new approximation.
>              if (f1 * fx < 0) {
> -                // The value of x1 has switched to the other bound, thus inverting
> +                // We had [x0..x1]. We update it to [x1, x]. Note that the
> +                // value of x1 has switched to the other bound, thus inverting
>                  // the interval.
>                  x0 = x1;
>                  f0 = f1;
> +                x1 = x;
> +                f1 = fx;
>                  inverted = !inverted;
>              } else {
> -                switch (method) {
> -                case ILLINOIS:
> +                // We had [x0..x1]. We update it to [x0, x].
> +                if (method == Method.ILLINOIS) {
>                      f0 *= 0.5;
> -                    break;
> -                case PEGASUS:
> -                    f0 *= f1 / (f1 + fx);
> -                    break;
13,14c32,33
<                          // Update formula cannot make any progress: Update the
<                          // search interval.
---
> -                        // Update formula cannot make any progress: Update the
> -                        // search interval.
19,20c38,39
<                  default:
<                      // Should never happen.
---
> -                default:
> -                    // Should never happen.
22a42,84
> +                if (method == Method.PEGASUS) {
> +                    f0 *= f1 / (f1 + fx);
>                  }
> -            // Update from [x0, x1] to [x0, x].
>                  x1 = x;
>                  f1 = fx;
> +            }
>  
>              // If the function value of the last approximation is too small,
>              // given the function value accuracy, then we can't get closer to
> diff --git a/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java b/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java
> index ef3a75a57..c89ac0e83 100644
> --- a/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java
> +++ b/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java
> @@ -17,10 +17,6 @@
>  
>  package org.apache.commons.math.analysis.solvers;
>  
> -import org.apache.commons.math.analysis.UnivariateRealFunction;
> -import org.junit.Test;
> -import org.junit.Assert;
> -
>  /**
>   * Test case for {@link RegulaFalsiSolver Regula Falsi} solver.
>   *
> @@ -39,18 +35,4 @@ public final class RegulaFalsiSolverTest extends BaseSecantSolverAbstractTest {
>          // even a million iterations. As such, it was disabled.
>          return new int[] {3, 7, 8, 19, 18, 11, 67, 55, 288, 151, -1};
>      }
> -
> -    @Test
> -    public void testIssue631() {
> -        final UnivariateRealFunction f = new UnivariateRealFunction() {
> -                @Override
> -                public double value(double x) {
> -                    return Math.exp(x) - Math.pow(Math.PI, 3.0);
> -                }
> -            };
> -
> -        final UnivariateRealSolver solver = new RegulaFalsiSolver();
> -        final double root = solver.solve(3624, f, 1, 10);
> -        Assert.assertEquals(3.4341896575482003, root, 1e-15);
> -	}
24d85
<              // Update from [x0, x1] to [x0, x].
