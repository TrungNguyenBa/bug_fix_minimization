2c2
< index 03c92eb..1ae554c 100644
---
> index 03c92eb20..8cb759075 100644
5c5
< @@ -181,43 +181,30 @@ public final class MathUtils {
---
> @@ -181,42 +181,11 @@ public final class MathUtils {
9,14c9
< +        long result = Math.round(binomialCoefficientDouble(n, k));
< +        if (result == Long.MAX_VALUE) {
< +            throw new ArithmeticException(
< +                "result too large to represent in a long integer");
< +        }
<          // Use symmetry for large k
---
> -        // Use symmetry for large k
17,22c12,17
<          
<          // We use the formula
<          // (n choose k) = n! / (n-k)! / k!
<          // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
<          // which could be written
<          // (n choose k) == (n-1 choose k-1) * n / k
---
> -        
> -        // We use the formula
> -        // (n choose k) = n! / (n-k)! / k!
> -        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
> -        // which could be written
> -        // (n choose k) == (n-1 choose k-1) * n / k
25c20
<              // For n <= 61, the naive implementation cannot overflow.
---
> -            // For n <= 61, the naive implementation cannot overflow.
30,31c25,26
<              // For n > 61 but n <= 66, the result cannot overflow,
<              // but we must take care not to overflow intermediate values.
---
> -            // For n > 61 but n <= 66, the result cannot overflow,
> -            // but we must take care not to overflow intermediate values.
33,38c28,33
<                  // We know that (result * i) is divisible by j,
<                  // but (result * i) may overflow, so we split j:
<                  // Filter out the gcd, d, so j/d and i/d are integer.
<                  // result is divisible by (j/d) because (j/d)
<                  // is relative prime to (i/d) and is a divisor of
<                  // result * (i/d).
---
> -                // We know that (result * i) is divisible by j,
> -                // but (result * i) may overflow, so we split j:
> -                // Filter out the gcd, d, so j/d and i/d are integer.
> -                // result is divisible by (j/d) because (j/d)
> -                // is relative prime to (i/d) and is a divisor of
> -                // result * (i/d).
43,45c38,40
<              // For n > 66, a result overflow might occur, so we check
<              // the multiplication, taking care to not overflow
<              // unnecessary.
---
> -            // For n > 66, a result overflow might occur, so we check
> -            // the multiplication, taking care to not overflow
> -            // unnecessary.
50c45,50
< -        }
---
> +
> +        long result = Math.round(binomialCoefficientDouble(n, k));
> +        if (result == Long.MAX_VALUE) {
> +            throw new ArithmeticException(
> +                "result too large to represent in a long integer");
>          }
53,54c53
<  
< @@ -244,33 +231,9 @@ public final class MathUtils {
---
> @@ -244,33 +213,7 @@ public final class MathUtils {
78c77
<          
---
> -        
83c82
<    
---
> -  
89,92c88,99
< @@ -311,17 +274,11 @@ public final class MathUtils {
<           * For values small enough to do exact integer computation,
<           * return the log of the exact value 
<           */
---
> @@ -304,28 +247,8 @@ public final class MathUtils {
>              return 0;
>          }
>          if ((k == 1) || (k == n - 1)) {
> -            return Math.log((double) n);
> +            return Math.log((double)n);
>          }
> -        
> -        /*
> -         * For values small enough to do exact integer computation,
> -         * return the log of the exact value 
> -         */
96,100c103,107
<          
<          /*
<           * Return the log of binomialCoefficientDouble for values that will not
<           * overflow binomialCoefficientDouble
<           */
---
> -        
> -        /*
> -         * Return the log of binomialCoefficientDouble for values that will not
> -         * overflow binomialCoefficientDouble
> -         */
103a111,279
> -        
> -        /*
> -         * Sum logs for values that could overflow
> -         */
>          double logSum = 0;
>  
>          // n!/k!
> diff --git a/src/site/xdoc/changes.xml b/src/site/xdoc/changes.xml
> index 8d5cb7eee..8ecb0f686 100644
> --- a/src/site/xdoc/changes.xml
> +++ b/src/site/xdoc/changes.xml
> @@ -39,9 +39,6 @@ The <action> type attribute can be add,update,fix,remove.
>    </properties>
>    <body>
>      <release version="2.0" date="TBD" description="TBD">
> -      <action dev="psteitz" type="fix" issue="MATH-241" due-to="Christian Semrau">
> -        Fixed error in binomial coefficient computation.
> -      </action>
>        <action dev="luc" type="add" >
>          Added a Legendre-Gauss integrator.
>        </action>
> diff --git a/src/test/org/apache/commons/math/util/MathUtilsTest.java b/src/test/org/apache/commons/math/util/MathUtilsTest.java
> index 0648cb3f7..8b953579d 100644
> --- a/src/test/org/apache/commons/math/util/MathUtilsTest.java
> +++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java
> @@ -14,10 +14,6 @@
>  package org.apache.commons.math.util;
>  
>  import java.math.BigDecimal;
> -import java.util.ArrayList;
> -import java.util.HashMap;
> -import java.util.List;
> -import java.util.Map;
>  
>  import junit.framework.Test;
>  import junit.framework.TestCase;
> @@ -43,37 +39,17 @@ public final class MathUtilsTest extends TestCase {
>          return suite;
>      }
>  
> -    /** cached binomial coefficients */
> -    private static List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>();
> -
>      /**
> -     * Exact (caching) recursive implementation to test against
> +     * Exact recursive implementation to test against
>       */
> -    private long binomialCoefficient(int n, int k) throws ArithmeticException {
> -        if (binomialCache.size() > n) {
> -            Long cachedResult = binomialCache.get(n).get(new Integer(k));
> -            if (cachedResult != null) {
> -                return cachedResult.longValue();
> -            }
> -        }
> -        long result = -1;
> +    private long binomialCoefficient(int n, int k) {
>          if ((n == k) || (k == 0)) {
> -            result = 1;
> -        } else if ((k == 1) || (k == n - 1)) {
> -            result = n;
> -        } else {
> -            result = MathUtils.addAndCheck(binomialCoefficient(n - 1, k - 1),
> -                binomialCoefficient(n - 1, k));
> +            return 1;
>          }
> -        if (result == -1) {
> -            throw new ArithmeticException(
> -                "error computing binomial coefficient");
> +        if ((k == 1) || (k == n - 1)) {
> +            return n;
>          }
> -        for (int i = binomialCache.size(); i < n + 1; i++) {
> -            binomialCache.add(new HashMap<Integer, Long>());
> -        }
> -        binomialCache.get(n).put(new Integer(k), new Long(result));
> -        return result;
> +        return binomialCoefficient(n - 1, k - 1) + binomialCoefficient(n - 1, k);
>      }
>  
>      /**
> @@ -165,63 +141,12 @@ public final class MathUtilsTest extends TestCase {
>              }
>          }
>  
> -        assertEquals(binomialCoefficient(34, 17), MathUtils
> -            .binomialCoefficient(34, 17));
> -    }
> -
> -    /**
> -     * Tests correctness for large n and sharpness of upper bound in API doc
> -     * JIRA: MATH-241
> +        /*
> +         * Takes a long time for recursion to unwind, but succeeds and yields
> +         * exact value = 2,333,606,220
> +         * assertEquals(MathUtils.binomialCoefficient(34,17),
> +         * binomialCoefficient(34,17));
>           */
> -    public void testBinomialCoefficientLarge() throws Exception {
> -        // This tests all legal and illegal values for n <= 200.
> -        for (int n = 0; n <= 200; n++) {
> -            for (int k = 0; k <= n; k++) {
> -                long ourResult = -1;
> -                long exactResult = -1;
> -                boolean shouldThrow = false;
> -                boolean didThrow = false;
> -                try {
> -                    ourResult = MathUtils.binomialCoefficient(n, k);
> -                } catch (ArithmeticException ex) {
> -                    didThrow = true;
> -                }
> -                try {
> -                    exactResult = binomialCoefficient(n, k);
> -                } catch (ArithmeticException ex) {
> -                    shouldThrow = true;
> -                }
> -                assertEquals(n+","+k, shouldThrow, didThrow);
> -                assertEquals(n+","+k, exactResult, ourResult);
> -                assertTrue(n+","+k, (n > 66 || !didThrow));
> -            }
> -        }
> -
> -        long ourResult = MathUtils.binomialCoefficient(300, 3);
> -        long exactResult = binomialCoefficient(300, 3);
> -        assertEquals(exactResult, ourResult);
> -
> -        ourResult = MathUtils.binomialCoefficient(700, 697);
> -        exactResult = binomialCoefficient(700, 697);
> -        assertEquals(exactResult, ourResult);
> -
> -        // This one should throw
> -        try {
> -            MathUtils.binomialCoefficient(700, 300);
> -            fail("Expecting ArithmeticException");
> -        } catch (ArithmeticException ex) {
> -            // Expected
> -        }
> -
> -        // Larger values cannot be computed directly by our
> -        // test implementation because of stack limitations,
> -        // so we make little jumps to fill the cache.
> -        for (int i = 2000; i <= 10000; i += 2000) {
> -            ourResult = MathUtils.binomialCoefficient(i, 3);
> -            exactResult = binomialCoefficient(i, 3);
> -            assertEquals(exactResult, ourResult);
> -        }
> -
>      }
>  
>      public void testBinomialCoefficientFail() {
> @@ -246,20 +171,13 @@ public final class MathUtilsTest extends TestCase {
>              ;
>          }
>          try {
> -            MathUtils.binomialCoefficient(67, 30);
> -            fail("expecting ArithmeticException");
> -        } catch (ArithmeticException ex) {
> -            ;
> -        }
> -        try {
>              MathUtils.binomialCoefficient(67, 34);
>              fail("expecting ArithmeticException");
>          } catch (ArithmeticException ex) {
>              ;
>          }
>          double x = MathUtils.binomialCoefficientDouble(1030, 515);
> -        assertTrue("expecting infinite binomial coefficient", Double
> -            .isInfinite(x));
> +        assertTrue("expecting infinite binomial coefficient", Double.isInfinite(x));
>      }
105,106c281
<          /*
<           * Sum logs for values that could overflow
---
>      public void testCosh() {
