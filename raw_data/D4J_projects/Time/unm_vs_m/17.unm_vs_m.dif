0a1,14
> diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
> index e0ea4ace..28732ee1 100644
> --- a/RELEASE-NOTES.txt
> +++ b/RELEASE-NOTES.txt
> @@ -67,9 +67,6 @@ Bug fixes since 2.0
>  - Time zone id parsing fixed for some longer time zones [3427389]
>    Time zones like "America/Dawson_Creek" were not parsed as "America/Dawson" was matched first
>  
> -- Time zone later/earlier offset methods failed in Western hemisphere [3476684]
> -  Previously, withLaterOffset() failed in the Americas, Now rewritten
> -
>  - Enhance readResolve() from LocalDate/LocalTime/LocalDateTime [3461008]
>    Handle even more weird deserialization problems with other tools
>  
2c16
< index 7219899..74a3802 100644
---
> index 72198993..ec05941f 100644
5,8c19,32
< @@ -1164,32 +1164,19 @@ public abstract class DateTimeZone implements Serializable {
<          // a bit messy, but will work in all non-pathological cases
<          
<          // evaluate 3 hours before and after to work out if anything is happening
---
> @@ -1,5 +1,5 @@
>  /*
> - *  Copyright 2001-2012 Stephen Colebourne
> + *  Copyright 2001-2011 Stephen Colebourne
>   *
>   *  Licensed under the Apache License, Version 2.0 (the "License");
>   *  you may not use this file except in compliance with the License.
> @@ -1161,37 +1161,14 @@ public abstract class DateTimeZone implements Serializable {
>       * @return the adjusted instant millis
>       */
>      public long adjustOffset(long instant, boolean earlierOrLater) {
> -        // a bit messy, but will work in all non-pathological cases
> -        
> -        // evaluate 3 hours before and after to work out if anything is happening
14,20c38,41
< +        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
< +        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
< +        if (instantBefore == instantAfter) {
<              return instant;  // not an overlap (less than is a gap, equal is normal case)
<          }
<          
<          // work out range of instants that have duplicate local times
---
> -            return instant;  // not an overlap (less than is a gap, equal is normal case)
> -        }
> -        
> -        // work out range of instants that have duplicate local times
28,31c49,50
< +        long local = convertUTCToLocal(instant);
< +        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
<          
<          // calculate result
---
> -        
> -        // calculate result
34c53
<            // currently in later offset
---
> -          // currently in later offset
37c56
<            // currently in earlier offset
---
> -          // currently in earlier offset
38a58,114
> +        long before = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
> +        long after = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
> +        if (before == after) {
> +            return instant;
>          }
> +        long local = convertUTCToLocal(instant);
> +        return convertLocalToUTC(local, false, earlierOrLater ? after : before);
>      }
> -//    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + " " + new DateTime(transitionStart, this));
>  
>      //-----------------------------------------------------------------------
>      /**
> diff --git a/src/test/java/org/joda/time/TestDateTimeZoneCutover.java b/src/test/java/org/joda/time/TestDateTimeZoneCutover.java
> index d86b68e0..a7a5175d 100644
> --- a/src/test/java/org/joda/time/TestDateTimeZoneCutover.java
> +++ b/src/test/java/org/joda/time/TestDateTimeZoneCutover.java
> @@ -1,5 +1,5 @@
>  /*
> - *  Copyright 2001-2012 Stephen Colebourne
> + *  Copyright 2001-2007 Stephen Colebourne
>   *
>   *  Licensed under the Apache License, Version 2.0 (the "License");
>   *  you may not use this file except in compliance with the License.
> @@ -1229,7 +1229,6 @@ public class TestDateTimeZoneCutover extends TestCase {
>          assertEquals(baseAfter.toString(), testAfter.toString());
>      }
>  
> -    //-------------------------------------------------------------------------
>      public void testBug3192457_adjustOffset() {
>          final DateTimeZone zone = DateTimeZone.forID("Europe/Paris");
>          DateTime base = new DateTime(2007, 10, 28, 3, 15, zone);
> @@ -1238,44 +1237,11 @@ public class TestDateTimeZoneCutover extends TestCase {
>          
>          assertSame(base, base.withEarlierOffsetAtOverlap());
>          assertSame(base, base.withLaterOffsetAtOverlap());
> -        
>          assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());
> -        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());
> -        
>          assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());
> -        assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());
> -    }
> -
> -    public void testBug3476684_adjustOffset() {
> -        final DateTimeZone zone = DateTimeZone.forID("America/Sao_Paulo");
> -        DateTime base = new DateTime(2012, 2, 25, 22, 15, zone);
> -        DateTime baseBefore = base.plusHours(1);  // 23:15 (first)
> -        DateTime baseAfter = base.plusHours(2);  // 23:15 (second)
> -        
> -        assertSame(base, base.withEarlierOffsetAtOverlap());
> -        assertSame(base, base.withLaterOffsetAtOverlap());
> -        
> -        assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());
> -        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());
>          
> -        assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());
>          assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());
39a116,131
> -
> -    public void testBug3476684_adjustOffset_springGap() {
> -      final DateTimeZone zone = DateTimeZone.forID("America/Sao_Paulo");
> -      DateTime base = new DateTime(2011, 10, 15, 22, 15, zone);
> -      DateTime baseBefore = base.plusHours(1);  // 23:15
> -      DateTime baseAfter = base.plusHours(2);  // 01:15
> -      
> -      assertSame(base, base.withEarlierOffsetAtOverlap());
> -      assertSame(base, base.withLaterOffsetAtOverlap());
> -      
> -      assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());
> -      assertEquals(baseBefore, baseBefore.withLaterOffsetAtOverlap());
> -      
> -      assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());
> -      assertEquals(baseAfter, baseAfter.withEarlierOffsetAtOverlap());
> +        assertEquals(baseAfter, baseAfter.withLaterOffsetAtOverlap());
41d132
<  //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + " " + new DateTime(transitionStart, this));
42a134
>      // ensure Summer time picked
