1,6c1,42
< diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java
< index 7c37fc1..b985cef 100644
< --- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java
< +++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java
< @@ -352,11 +352,6 @@ public class DateTimeParserBucket {
<              for (int i = 0; i < count; i++) {
---
> diff --git a/JodaTime/RELEASE-NOTES.txt b/JodaTime/RELEASE-NOTES.txt
> index 6cc5bbda..eee3045b 100644
> --- a/JodaTime/RELEASE-NOTES.txt
> +++ b/JodaTime/RELEASE-NOTES.txt
> @@ -160,9 +160,6 @@ This affects the constructor of DateTime and other methods.
>  Previously, DateTimeZone.getMillisKeepLocal used DateTimeZone.getOffsetFromLocal, now it uses
>  DateTimeZone.convertUTCToLocal and DateTimeZone.convertLocalToUTC retaining the offset where possible
>  
> -Previously, some parses of mixed weekyear and month formats would yield a result about a year out
> -Now, most (but not all) of these give a more appropriate result
> -
>  
>  Deprecations since 1.6
>  ----------------------
> @@ -220,10 +217,6 @@ Bug fixes since 1.6
>  
>  - Standard DateTimeFieldType implements hashCode and equals for stability across serialization
>  
> -- Conversion from parsed values to a date-time handles weird sets of fields better [3161586]
> -  This change is mostly for combinations like weekyear-month-week
> -  The new code doesn't handle all combinations perfectly, but its better than it was
> -
>  - Time zone compiler now handles 24:00 [2804258]
>  
>  - Time zone compiler now handles non-UTC better
> diff --git a/JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java
> index 7c37fc1f..44255a61 100644
> --- a/JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java
> +++ b/JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java
> @@ -1,5 +1,5 @@
>  /*
> - *  Copyright 2001-2011 Stephen Colebourne
> + *  Copyright 2001-2009 Stephen Colebourne
>   *
>   *  Licensed under the Apache License, Version 2.0 (the "License");
>   *  you may not use this file except in compliance with the License.
> @@ -349,14 +349,9 @@ public class DateTimeParserBucket {
>  
>          long millis = iMillis;
>          try {
> -            for (int i = 0; i < count; i++) {
> +            for (int i=0; i<count; i++) {
16a53,138
> diff --git a/JodaTime/src/test/java/org/joda/time/format/TestDateTimeFormatter.java b/JodaTime/src/test/java/org/joda/time/format/TestDateTimeFormatter.java
> index 53263709..ca3c866b 100644
> --- a/JodaTime/src/test/java/org/joda/time/format/TestDateTimeFormatter.java
> +++ b/JodaTime/src/test/java/org/joda/time/format/TestDateTimeFormatter.java
> @@ -1,5 +1,5 @@
>  /*
> - *  Copyright 2001-2011 Stephen Colebourne
> + *  Copyright 2001-2009 Stephen Colebourne
>   *
>   *  Licensed under the Apache License, Version 2.0 (the "License");
>   *  you may not use this file except in compliance with the License.
> @@ -422,74 +422,6 @@ public class TestDateTimeFormatter extends TestCase {
>          assertEquals(new LocalDate(2012, 2, 29, chrono), f.parseLocalDate("2 29"));
>      }
>  
> -    public void testParseLocalDate_weekyear_month_week_2010() {
> -        Chronology chrono = GJChronology.getInstanceUTC();
> -        DateTimeFormatter f = DateTimeFormat.forPattern("xxxx-MM-ww").withChronology(chrono);
> -        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate("2010-01-01"));
> -    }
> -
> -    public void testParseLocalDate_weekyear_month_week_2011() {
> -        Chronology chrono = GJChronology.getInstanceUTC();
> -        DateTimeFormatter f = DateTimeFormat.forPattern("xxxx-MM-ww").withChronology(chrono);
> -        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate("2011-01-01"));
> -    }
> -
> -    public void testParseLocalDate_weekyear_month_week_2012() {
> -        Chronology chrono = GJChronology.getInstanceUTC();
> -        DateTimeFormatter f = DateTimeFormat.forPattern("xxxx-MM-ww").withChronology(chrono);
> -        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate("2012-01-01"));
> -    }
> -
> -// This test fails, but since more related tests pass with the extra loop in DateTimeParserBucket
> -// I'm going to leave the change in and ignore this test
> -//    public void testParseLocalDate_weekyear_month_week_2013() {
> -//        Chronology chrono = GJChronology.getInstanceUTC();
> -//        DateTimeFormatter f = DateTimeFormat.forPattern("xxxx-MM-ww").withChronology(chrono);
> -//        assertEquals(new LocalDate(2012, 12, 31, chrono), f.parseLocalDate("2013-01-01"));
> -//    }
> -
> -    public void testParseLocalDate_year_month_week_2010() {
> -        Chronology chrono = GJChronology.getInstanceUTC();
> -        DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono);
> -        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate("2010-01-01"));
> -    }
> -
> -    public void testParseLocalDate_year_month_week_2011() {
> -        Chronology chrono = GJChronology.getInstanceUTC();
> -        DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono);
> -        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate("2011-01-01"));
> -    }
> -
> -    public void testParseLocalDate_year_month_week_2012() {
> -        Chronology chrono = GJChronology.getInstanceUTC();
> -        DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono);
> -        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate("2012-01-01"));
> -    }
> -
> -    public void testParseLocalDate_year_month_week_2013() {
> -        Chronology chrono = GJChronology.getInstanceUTC();
> -        DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono);
> -        assertEquals(new LocalDate(2012, 12, 31, chrono), f.parseLocalDate("2013-01-01"));  // 2013-01-01 would be better, but this is OK
> -    }
> -
> -    public void testParseLocalDate_year_month_week_2014() {
> -        Chronology chrono = GJChronology.getInstanceUTC();
> -        DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono);
> -        assertEquals(new LocalDate(2013, 12, 30, chrono), f.parseLocalDate("2014-01-01"));  // 2014-01-01 would be better, but this is OK
> -    }
> -
> -    public void testParseLocalDate_year_month_week_2015() {
> -        Chronology chrono = GJChronology.getInstanceUTC();
> -        DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono);
> -        assertEquals(new LocalDate(2014, 12, 29, chrono), f.parseLocalDate("2015-01-01"));  // 2015-01-01 would be better, but this is OK
> -    }
> -
> -    public void testParseLocalDate_year_month_week_2016() {
> -        Chronology chrono = GJChronology.getInstanceUTC();
> -        DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono);
> -        assertEquals(new LocalDate(2016, 1, 4, chrono), f.parseLocalDate("2016-01-01"));
> -    }
> -
>      //-----------------------------------------------------------------------
>      public void testParseLocalTime_simple() {
>          assertEquals(new LocalTime(10, 20, 30), g.parseLocalTime("2004-06-09T10:20:30Z"));
