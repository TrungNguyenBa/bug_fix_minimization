diff --git a/include/faunus/analysis.h b/include/faunus/analysis.h
index 79a08349..e0bfed4b 100755
--- a/include/faunus/analysis.h
+++ b/include/faunus/analysis.h
@@ -12,6 +12,9 @@
 #include <Eigen/Core>
 #include <chrono>
 #include <thread>
+#ifdef ENABLE_MPI
+#include <faunus/mpi.h>
+#endif
 
 namespace Faunus {
 
@@ -197,6 +200,1036 @@ namespace Faunus {
           }
     };
 
+    /**
+     * @brief General class for handling 2D tables - xy data, for example.
+     * @date Lund 2011
+     * @note `Tx` is used as the `std::map` key and which may be
+     * problematic due to direct floating point comparison (== operator).
+     * We have not experienced any issues with this, though. This uses
+     * `std::map` and table lookup is of complexity logarithmic with N.
+     */
+    template<typename Tx, typename Ty>
+      class Table2D {
+        protected:
+          typedef std::map<Tx,Ty> Tmap;
+          Ty count() {
+            Ty cnt=0;
+            for (auto &m : map)
+              cnt+=m.second;
+            return cnt;
+          }
+          Tx dx;
+          Tmap map;
+          string name;
+        private:
+          Tx round(Tx x) { return (x>=0) ? int( x/dx+0.5 )*dx : int( x/dx-0.5 )*dx; }
+          virtual double get(Tx x) { return operator()(x); }
+        public:
+          enum type {HISTOGRAM, XYDATA};
+          type tabletype;
+
+          /**
+           * @brief Constructor
+           * @param resolution Resolution of the x axis
+           * @param key Table type: HISTOGRAM or XYDATA
+           */
+          Table2D(Tx resolution=0.2, type key=XYDATA) {
+            tabletype=key;
+            setResolution(resolution);
+          }
+
+          void clear() { map.clear(); }
+
+          void setResolution(Tx resolution) {
+            assert( resolution>0 );
+            dx=resolution;
+            map.clear();
+          }
+
+          virtual ~Table2D() {}
+
+          /** @brief Access operator - returns reference to y(x) */
+          Ty& operator() (Tx x) {
+            return map[ round(x) ];
+          }
+
+          /** @brief Find key and return corresponding value otherwise zero*/
+          Ty find(Tx &x) {
+            Ty value = 0;
+            auto it = map.find( round(x) );
+            if (it!=map.end()) value = it->second;
+            return value;
+          }
+
+          /** @brief Save table to disk */
+          template<class T=double>
+            void save(string filename, T scale=1, T translate=0) {
+              if (tabletype==HISTOGRAM) {
+                if (!map.empty()) map.begin()->second*=2;   // compensate for half bin width
+                if (map.size()>1) (--map.end())->second*=2; // -//-
+              }
+
+              if (!map.empty()) {
+                std::ofstream f(filename.c_str());
+                f.precision(10);
+                if (f) {
+                  for (auto &m : map)
+                    f << m.first << " " << (m.second + translate) * scale << "\n";
+                }
+              }
+
+              if (tabletype==HISTOGRAM) {
+                if (!map.empty()) map.begin()->second/=2;   // restore half bin width
+                if (map.size()>1) (--map.end())->second/=2; // -//-
+              }
+            }
+
+          /** @brief Save normalized table to disk */
+          template<class T=double>
+            void normSave(string filename) {
+              if (tabletype==HISTOGRAM) {
+                if (!map.empty()) map.begin()->second*=2;   // compensate for half bin width
+                if (map.size()>1) (--map.end())->second*=2; // -//-
+              }
+
+              if (!map.empty()) {
+                std::ofstream f(filename.c_str());
+                f.precision(10);
+                Ty cnt = count()*dx;
+                if (f) {
+                  for (auto &m : map)
+                    f << m.first << " " << m.second/cnt << "\n";
+                }
+              }
+
+              if (tabletype==HISTOGRAM) {
+                if (!map.empty()) map.begin()->second/=2;   // restore half bin width
+                if (map.size()>1) (--map.end())->second/=2; // -//-
+              }
+            }
+
+          /** @brief Sums up all previous elements and saves table to disk */
+          template<class T=double>
+            void sumSave(string filename, T scale=1) {
+              if (tabletype==HISTOGRAM) {
+                if (!map.empty()) map.begin()->second*=2;   // compensate for half bin width
+                if (map.size()>1) (--map.end())->second*=2; // -//-
+              }
+
+              if (!map.empty()) {
+                std::ofstream f(filename.c_str());
+                f.precision(10);
+                if (f) {
+                  Ty sum_t = 0.0;
+                  for (auto &m : map) {
+                    sum_t += m.second;
+                    f << m.first << " " << sum_t * scale << "\n";
+                  }
+                }
+              }
+
+              if (tabletype==HISTOGRAM) {
+                if (!map.empty()) map.begin()->second/=2;   // restore half bin width
+                if (map.size()>1) (--map.end())->second/=2; // -//-
+              }
+            }
+
+          Tmap getMap() {
+            return map;
+          }
+
+          Tx getResolution() {
+            return dx;
+          }
+
+          /*! Returns average */
+          Tx mean() {
+            assert(!map.empty());
+            Tx ave = 0;
+            for (auto &m : map) ave += m.first*m.second;
+            return ave/count();
+          }
+
+          /*! Returns standard deviation */
+          Tx std() {
+            assert(!map.empty());
+            Tx std2 = 0;
+            Tx ave = mean();
+            for (auto &m : map) std2 += m.second*(m.first - ave)*(m.first - ave);
+            return sqrt(std2/count());
+          }
+
+          /*! Returns iterator of minumum y */
+          typename Tmap::const_iterator min() {
+            assert(!map.empty());
+            Ty min=std::numeric_limits<Ty>::max();
+            typename Tmap::const_iterator it;
+            for (auto m=map.begin(); m!=map.end(); ++m)
+              if (m->second<min) {
+                min=m->second;
+                it=m;
+              }
+            return it;
+          }
+
+          /*! Returns iterator of maximum y */
+          typename Tmap::const_iterator max() {
+            assert(!map.empty());
+            Ty max=std::numeric_limits<Ty>::min();
+            typename Tmap::const_iterator it;
+            for (auto m=map.begin(); m!=map.end(); ++m)
+              if (m->second>max) {
+                max=m->second;
+                it=m;
+              }
+            return it;
+          }
+
+          /*! Returns x at minumum x */
+          Tx minx() {
+            assert(!map.empty());
+            Tx x=0;
+            for (auto &m : map) {
+              x=m.first;
+              break;
+            }
+            return x;
+          }
+
+          /*! Returns average in interval */
+          Ty ave(Tx limit1, Tx limit2) {
+            Ty ave = 0;
+            int cnt = 0;
+            assert(!map.empty());
+            for (auto &m : map) {
+              if (m.first>=limit1 && m.first<=limit2) {
+                ave+=m.second;
+                ++cnt;  
+              }
+            }
+            return ave/cnt;
+          }
+
+          /**
+           * @brief Convert table2D to vector of floats
+           */
+          vector<double> hist2buf(int &size) {
+            std::vector<double> sendBuf;
+            assert(!map.empty());
+            for (auto &m : map) {
+              sendBuf.push_back(m.first);
+              sendBuf.push_back(double(m.second));
+            }
+            sendBuf.resize(size,0);
+            return sendBuf;
+          }
+
+          /**
+           * @brief Convert vector of floats to table2D
+           */
+          void buf2hist(vector<double> &v) {
+            this->clear();
+            assert(!v.empty());
+            for (int i=0; i<v.size(); i+=2) {
+              if (int(v[i+1])!=0) this->operator()(v[i])+=int(v[i+1]);
+            }
+          }
+
+          /**
+           * @brief Load table from disk
+           * @note The first line - used for comments - is ignored.
+           * @todo Implement end bin compensation as in the save()
+           * function when loading HISTOGRAMs
+           */
+          bool load(const string &filename) {
+            std::ifstream f(filename.c_str());
+            if (f) {
+              map.clear();
+              while (!f.eof()) {
+                Tx x;
+                double y;
+                f >> x >> y;
+                operator()(x)=y;
+              }
+              if (tabletype==HISTOGRAM) {
+                if (!map.empty()) map.begin()->second/=2;   // restore half bin width
+                if (map.size()>1) (--map.end())->second/=2; // -//-
+              }
+              return true;
+            }
+            return false;
+          }
+
+          /**
+           * @brief Convert table to matrix
+           */
+          Eigen::MatrixXd tableToMatrix() {
+            assert(!this->map.empty() && "Map is empty!");
+            Eigen::MatrixXd table(2,map.size());
+            table.setZero();
+            int I = 0;
+            for (auto &m : this->map) {
+              table(0,I) = m.first;
+              table(1,I) = m.second;
+              I++;
+            }
+            return table;
+          }
+      };
+    /**
+     * @brief Subtract two tables
+     */
+    template<class Tx, class Ty, class Tmap>
+      Table2D<Tx,Ty> operator-(Table2D<Tx,Ty> &a, Table2D<Tx,Ty> &b) {
+        assert(a.tabletype=b.tabletype && "Table a and b needs to be of same type");
+        Table2D<Tx,Ty> c(std::min(a.getResolution(),b.getResolution()),a.tabletype);
+        Tmap a_map = a.getMap();
+        Tmap b_map = b.getMap();
+
+        if (a.tabletype=="HISTOGRAM") {
+          if (!a_map.empty()) a_map.begin()->second*=2;   // compensate for half bin width
+          if (a_map.size()>1) (--a_map.end())->second*=2; // -//-
+          if (!b_map.empty()) b_map.begin()->second*=2;   // compensate for half bin width
+          if (b_map.size()>1) (--b_map.end())->second*=2; // -//-
+        }
+
+        for (auto &m1 : a_map) {
+          for (auto &m2 : b_map) {
+            c(m1.first) = m1.second-m2.second;
+            break;
+          }
+        }
+
+        if (a.tabletype=="HISTOGRAM") {
+          if (!a_map.empty()) a_map.begin()->second/=2;   // compensate for half bin width
+          if (a_map.size()>1) (--a_map.end())->second/=2; // -//-
+          if (!b_map.empty()) b_map.begin()->second/=2;   // compensate for half bin width
+          if (b_map.size()>1) (--b_map.end())->second/=2; // -//-
+        }
+        return c;
+      }
+
+    /**
+     * @brief Addition two tables
+     */
+    template<class Tx, class Ty, class Tmap>
+      Table2D<Tx,Ty> operator+(Table2D<Tx,Ty> &a, Table2D<Tx,Ty> &b) {
+        assert(a.tabletype=b.tabletype && "Table a and b needs to be of same type");
+        Table2D<Tx,Ty> c(std::min(a.getResolution(),b.getResolution()),a.tabletype);
+        Tmap a_map = a.getMap();
+        Tmap b_map = b.getMap();
+
+        if (a.tabletype=="HISTOGRAM") {
+          if (!a_map.empty()) a_map.begin()->second*=2;   // compensate for half bin width
+          if (a_map.size()>1) (--a_map.end())->second*=2; // -//-
+          if (!b_map.empty()) b_map.begin()->second*=2;   // compensate for half bin width
+          if (b_map.size()>1) (--b_map.end())->second*=2; // -//-
+        }
+
+        for (auto &m : a_map) {
+          c(m.first) += m.second;
+        }
+        for (auto &m : b_map) {
+          c(m.first) += m.second;
+        }
+
+        if (a.tabletype=="HISTOGRAM") {
+          if (!a_map.empty()) a_map.begin()->second/=2;   // compensate for half bin width
+          if (a_map.size()>1) (--a_map.end())->second/=2; // -//-
+          if (!b_map.empty()) b_map.begin()->second/=2;   // compensate for half bin width
+          if (b_map.size()>1) (--b_map.end())->second/=2; // -//-
+        }
+
+        return c;
+      }
+
+    template<typename Tx, typename Ty>
+      class Table3D {
+        protected:
+          typedef std::map<std::pair<Tx,Tx>,Ty> Tmap;
+          Tx dx1, dx2;
+          Tmap map;
+          string name;
+          Ty count() {
+            Ty cnt=0;
+            for (auto &m : map)
+              cnt+=m.second;
+            return cnt;
+          }
+        private:
+          Tx round1(Tx x) { return (x>=0) ? int( x/dx1+0.5 )*dx1 : int( x/dx1-0.5 )*dx1; }
+          Tx round2(Tx x) { return (x>=0) ? int( x/dx2+0.5 )*dx2 : int( x/dx2-0.5 )*dx2; }
+          virtual double get(Tx x1, Tx x2) { return operator()(x1, x2); }
+        public:
+          enum type {HISTOGRAM, XYDATA};
+          type tabletype;
+
+          /**
+           * @brief Constructor
+           * @param resolution Resolution of the x axis
+           * @param key Table type: HISTOGRAM or XYDATA
+           */
+          Table3D(Tx resolution1=1, Tx resolution2=1, type key=XYDATA) {
+            tabletype=key;
+            setResolution(resolution1, resolution2);
+          }
+
+          void clear() { map.clear(); }
+
+          void setResolution(Tx resolution1, Tx resolution2) {
+            assert( resolution1>0 && resolution2>0 );
+            dx1=resolution1;
+            dx2=resolution2;
+            map.clear();
+          }
+
+          virtual ~Table3D() {}
+
+          /** @brief Access operator - returns reference to y(x) */
+          Ty& operator() (Tx x1, Tx x2) {
+            return map[ std::make_pair(round1(x1),round2(x2)) ];
+          }
+
+          /** @brief Find key and return corresponding value otherwise zero*/
+          Ty find(std::pair<Tx,Tx> &xp) {
+            Ty value = 0;
+            auto it = map.find( std::make_pair(round1(xp.first),round2(xp.second)));
+            if (it!=map.end()) value = it->second;
+            return value;
+          }
+
+          /** @brief Save table to disk */
+          void save(string filename, Ty scale=1, Ty translate=0) {
+            if (tabletype==HISTOGRAM) { // compensate for half bin width
+              auto first = map.begin();
+              auto last = map.rbegin();
+              if (!map.empty()) {
+                for (auto it = first; it != map.end(); ++it) {
+                  if (it->first.first == first->first.first) it->second*=2;
+                  else if (it->first.second == first->first.second) it->second*=2;
+                }
+              }
+              if (map.size()>1) {
+                for (auto it = last; it != map.rend(); ++it) {
+                  if (it->first.first == last->first.first) it->second*=2;
+                  else if (it->first.second == last->first.second) it->second*=2;
+                }
+              }
+            }
+
+            if (!map.empty()) {
+              std::ofstream f(filename.c_str());
+              f.precision(10);
+              if (f) {
+                for (auto &m : map)
+                  f << m.first.first << " " << m.first.second 
+                    << " " << (m.second + translate) * scale << "\n";
+              }
+            }
+
+            if (tabletype==HISTOGRAM) { // restore half bin width
+              auto first = map.begin();
+              auto last = map.rbegin();
+              if (!map.empty()) {
+                for (auto it = first; it != map.end(); ++it) {
+                  if (it->first.first == first->first.first) it->second/=2;
+                  else if (it->first.second == first->first.second) it->second/=2;
+                }
+              }
+              if (map.size()>1) {
+                for (auto it = last; it != map.rend(); ++it) {
+                  if (it->first.first == last->first.first) it->second/=2;
+                  else if (it->first.second == last->first.second) it->second/=2;
+                }
+              }
+            }
+          }
+
+          /** @brief Save normalized table to disk */
+          void normSave(string filename) {
+            if (tabletype==HISTOGRAM) { // compensate for half bin width
+              auto first = map.begin();
+              auto last = map.rbegin();
+              if (!map.empty()) {
+                for (auto it = first; it != map.end(); ++it) {
+                  if (it->first.first == first->first.first) it->second*=2;
+                  else if (it->first.second == first->first.second) it->second*=2;
+                }
+              }
+              if (map.size()>1) {
+                for (auto it = last; it != map.rend(); ++it) {
+                  if (it->first.first == last->first.first) it->second*=2;
+                  else if (it->first.second == last->first.second) it->second*=2;
+                }
+              }
+            }
+
+            if (!map.empty()) {
+              std::ofstream f(filename.c_str());
+              f.precision(10);
+              Ty cnt = count()*dx1*dx2;
+              if (f) {
+                for (auto &m : map)
+                  f << m.first.first << " " << m.first.second
+                    << " " << m.second/cnt << "\n";
+              }
+            }
+
+            if (tabletype==HISTOGRAM) { // restore half bin width
+              auto first = map.begin();
+              auto last = map.rbegin();
+              if (!map.empty()) {
+                for (auto it = first; it != map.end(); ++it) {
+                  if (it->first.first == first->first.first) it->second/=2;
+                  else if (it->first.second == first->first.second) it->second/=2;
+                }
+              }
+              if (map.size()>1) {
+                for (auto it = last; it != map.rend(); ++it) {
+                  if (it->first.first == last->first.first) it->second/=2;
+                  else if (it->first.second == last->first.second) it->second/=2;
+                }
+              }
+            }
+          }
+
+          Tmap getMap() {
+            return map;
+          }
+
+          /*! Returns iterator of minumum y */
+          typename Tmap::const_iterator min() {
+            assert(!map.empty());
+            Ty min=std::numeric_limits<Ty>::max();
+            typename Tmap::const_iterator it;
+            for (auto m=map.begin(); m!=map.end(); ++m)
+              if (m->second<min) {
+                min=m->second;
+                it=m;
+              }
+            return it;
+          }
+
+          /*! Returns iterator of maximum y */
+          typename Tmap::const_iterator max() {
+            assert(!map.empty());
+            Ty max=std::numeric_limits<Ty>::min();
+            typename Tmap::const_iterator it;
+            for (auto m=map.begin(); m!=map.end(); ++m)
+              if (m->second>max) {
+                max=m->second;
+                it=m;
+              }
+            return it;
+          }
+
+          /*! Returns average in interval */
+          Ty ave(Tx limit1_x1, Tx limit2_x1, Tx limit1_x2, Tx limit2_x2) {
+            Ty ave = 0;
+            int cnt = 0;
+            assert(!map.empty());
+            for (auto &m : map) {
+              if (m.first.first>=limit1_x1 && m.first.first<=limit2_x1
+                  && m.first.second>=limit1_x2 && m.first.second<=limit2_x2) {
+                ave+=m.second;
+                ++cnt;  
+              }
+            }
+            return ave/cnt;
+          }
+
+          /**
+           * @brief Convert table3D to vector of floats
+           */
+          vector<double> hist2buf(int &size) {
+            std::vector<double> sendBuf;
+            assert(!map.empty());
+            for (auto &m : map) {
+              sendBuf.push_back(m.first.first);
+              sendBuf.push_back(m.first.second);
+              sendBuf.push_back(double(m.second));
+            }
+            sendBuf.resize(size,0);
+            return sendBuf;
+          }
+
+          /**
+           * @brief Convert vector of floats to table3D
+           */
+          void buf2hist(vector<double> &v) {
+            this->clear();
+            assert(!v.empty());
+            for (int i=0; i<v.size(); i+=3) {
+              if (v[i+2]!=0) this->operator()(v[i],v[i+1])+=int(v[i+2]);
+            }
+          }
+
+          /**
+           * @brief Load table from disk
+           */
+          bool load(const string &filename) {
+            std::ifstream f(filename.c_str());
+            if (f) {
+              map.clear();
+              while (!f.eof()) {
+                Tx x1, x2;
+                Ty y;
+                f >> x1 >> x2 >> y;
+                operator()(x1,x2)=y;
+              }
+              if (tabletype==HISTOGRAM) { // restore half bin width
+                auto first = map.begin();
+                auto last = map.rbegin();
+                if (!map.empty()) {
+                  for (auto it = first; it != map.end(); ++it) {
+                    if (it->first.first == first->first.first) it->second/=2;
+                    else if (it->first.second == first->first.second) it->second/=2;
+                  }
+                }
+                if (map.size()>1) {
+                  for (auto it = last; it != map.rend(); ++it) {
+                    if (it->first.first == last->first.first) it->second/=2;
+                    else if (it->first.second == last->first.second) it->second/=2;
+                  }
+                }
+              }
+              return true;
+            }
+            return false;
+          }
+      };
+
+#ifdef ENABLE_MPI
+    template<typename Tcoord=double>
+      class PenaltyFunction1D : public Table2D<Tcoord,double> {
+        private:
+          int _cnt;
+          int _Nupdate;
+          double _du;
+          double _du_sum;
+          int _size; // maximum number of keys in the map
+          typedef Faunus::MPI::FloatTransmitter::floatp floatp;
+          typedef Table2D<Tcoord,double> Tbase;
+          typedef Table2D<Tcoord,double> Thist;
+          typedef std::pair<Tcoord,Tcoord> Tpair;
+          Thist hist;
+          Faunus::MPI::MPIController *mpiPtr; 
+          Faunus::MPI::FloatTransmitter ft;
+        public:
+          /**
+           * @brief Constructor
+           * @param MPI controller
+           * @param Nupdate Number of moves between updates of the penalty function
+           * @param res1 Resolution of the reaction coordinate (default 1)
+           * @param size Total number of points in the penalty function
+           */
+          PenaltyFunction1D(Faunus::MPI::MPIController &mpi, int Nupdate, size_t size, Tcoord res1, Tcoord res2)
+            : Tbase(res1, Tbase::XYDATA), hist(res1, Thist::XYDATA), mpiPtr(&mpi) {
+              Tbase::name = "1D Penalty Function";
+              _size = size*2;
+              _cnt = 0;
+              _du = 0;
+              _Nupdate = Nupdate;
+              _du_sum = 0;
+            }
+          /**
+           * @brief The slaves send histograms to the master
+           * @brief The master computes the sum over all histograms and sends it to the slaves
+           */
+          void exchange() {
+            if (!mpiPtr->isMaster()) {
+              std::vector<floatp> sendBuf = hist.hist2buf(_size);
+              std::vector<floatp> recvBuf = ft.swapf(*mpiPtr, sendBuf, mpiPtr->rankMaster());
+              hist.buf2hist(recvBuf);
+            }
+            if (mpiPtr->isMaster()) {
+              std::vector<floatp> sendBuf = hist.hist2buf(_size);
+              std::vector<floatp> recvBuf(_size);
+              for (int i=0; i<mpiPtr->nproc(); ++i) {
+                if (i==mpiPtr->rankMaster()) continue;
+                ft.recvf(*mpiPtr, i, recvBuf);
+                ft.waitrecv();
+                sendBuf.insert(sendBuf.end(), recvBuf.begin(), recvBuf.end());
+              }
+              hist.buf2hist(sendBuf);
+              sendBuf = hist.hist2buf(_size);
+              for (int i=1; i<mpiPtr->nproc(); ++i) {
+                ft.sendf(*mpiPtr, sendBuf, i);
+                ft.waitsend();
+              }
+              hist.buf2hist(sendBuf);
+            }
+          }
+
+          /** 
+           * @brief Update histogram of the single process 
+           * @brief Merge histograms from all processes and update the penalty function
+           */
+          double update(Tcoord coord) {
+            _cnt++;
+            hist(coord)++; // increment internal histogram
+            _du = 0;
+            if ((_cnt%_Nupdate)==0) { // if Nupdate'th time
+              exchange();
+              for (auto &m : hist.getMap()) { // update penalty function
+                Tbase::operator()(m.first) += std::log(m.second);
+              }
+              double min = Tbase::min()->second;
+              for (auto &m : Tbase::getMap()) {
+                Tbase::operator()(m.first) -= min;
+              }
+              assert(hist(coord)!=0 && "hist_size (>= max # of points in histogram) is set too small.");
+              _du = std::log(hist(coord)) - min; // prevents energy drift
+              _du_sum += _du;
+              hist.clear();
+            }
+            return _du;
+          }
+
+          /**
+           * @brief Update histogram of the single process using both the accepted and rejected 
+           * configutations according to the waste_recycling method. DOI:10.1007/3-540-35273-2_4
+           * Merge histograms from all processes and update the penalty function
+           */
+          double update_recycle(Tpair coord, double weight, bool rejection) {
+            _cnt++;
+            if (weight < 1) {
+              hist(coord.first) += (1-weight);
+              hist(coord.second) += weight;
+            }
+            else hist(coord.second)++;
+            _du = 0;
+            if ((_cnt%_Nupdate)==0) { // if Nupdate'th time
+              exchange();
+              for (auto &m : hist.getMap()) { // update penalty function
+                Tbase::operator()(m.first) += std::log(m.second);
+              }
+              double min = Tbase::min()->second;
+              for (auto &m : Tbase::getMap()) {
+                Tbase::operator()(m.first) -= min;
+              }
+              if (!rejection) _du = std::log(hist(coord.second)) - min;
+              else _du = std::log(hist(coord.first)) - min;
+              assert(hist(coord.second)!=0 && "hist_size (>= max # of points in histogram) is set too small.");
+              _du_sum += _du;
+              hist.clear();
+            }
+            return _du;
+          }
+
+          /*! \brief Save table to disk */
+          void save(const string &filename) {
+            Tbase::save(filename);
+            hist.save(filename+".dist");
+          }
+
+          /*! \brief Translate penalty by a reference value and save it to disk */
+          void save_final(const string &filename, Tcoord a, Tcoord b) {
+            double ref_value = - Tbase::ave(a,b);
+            Tbase::save(filename,1.,ref_value);
+          }
+
+          /*! \brief Load table to disk */
+          void load(const string &filename) {
+            Tbase::load(filename);
+            hist.load(filename+".dist");
+          }
+
+          void test(UnitTest &t) {
+            auto it_max = Tbase::max();
+            auto it_min = Tbase::min();
+            t("Penalty range",it_max->second-it_min->second,2.);
+          }
+
+          string info() {
+            using namespace Faunus::textio;
+            std::ostringstream o;
+            o << header("1D penalty function");
+            if (_cnt/_Nupdate>=1) {
+              char w=25;
+              auto it_max = Tbase::max();
+              auto it_min = Tbase::min();
+              o << textio::pad(SUB,w, "Number of updates") << _cnt/_Nupdate << endl
+                << textio::pad(SUB,w, "Point of lowest penalty") << it_min->first 
+                << " " << angstrom << endl
+                << textio::pad(SUB,w, "Point of highest penalty") << it_max->first
+                << " " << angstrom << endl
+                << textio::pad(SUB,w, "Penalty range") << it_max->second-it_min->second << kT << endl
+                << textio::pad(SUB,w, "Drift compensation") << _du_sum << kT << endl;
+            }
+            return o.str();
+          }
+      };
+
+    template<typename Tcoord=double>
+      class PenaltyFunction2D : public Table3D<Tcoord,double> {
+        private:
+          int _cnt;
+          int _Nupdate;
+          double _du;
+          double _du_sum;
+          int _size; // maximum number of keys in the map
+          typedef Faunus::MPI::FloatTransmitter::floatp floatp;
+          typedef Table3D<Tcoord,double> Tbase;
+          typedef Table3D<Tcoord,double> Thist;
+          typedef std::pair<Tcoord,Tcoord> Tpair;
+          Thist hist;
+          Faunus::MPI::MPIController *mpiPtr; 
+          Faunus::MPI::FloatTransmitter ft;
+        public:
+          /**
+           * @brief Constructor
+           * @param MPI controller
+           * @param Nupdate Number of moves between updates of the penalty function
+           * @param res1 Resolution of one coordinate (default 1)
+           * @param res2 Resolution of the other coordinate (default 1)
+           * @param size Total number of points in the penalty function
+           */
+          PenaltyFunction2D(Faunus::MPI::MPIController &mpi, int Nupdate, size_t size, Tcoord res1, Tcoord res2)
+            : Tbase(res1, res2, Tbase::XYDATA), hist(res1, res2, Thist::XYDATA), mpiPtr(&mpi) {
+              Tbase::name = "2D Penalty Function";
+              _size = size*3;
+              _cnt = 0;
+              _du = 0;
+              _Nupdate = Nupdate;
+              _du_sum = 0;
+            }
+          /**
+           * @brief The slaves send histograms to the master
+           * @brief The master computes the sum over all histograms and sends it to the slaves
+           */
+          void exchange() {
+            if (!mpiPtr->isMaster()) {
+              std::vector<floatp> sendBuf = hist.hist2buf(_size);
+              std::vector<floatp> recvBuf = ft.swapf(*mpiPtr, sendBuf, mpiPtr->rankMaster());
+              hist.buf2hist(recvBuf);
+            }
+            if (mpiPtr->isMaster()) {
+              std::vector<floatp> sendBuf = hist.hist2buf(_size);
+              std::vector<floatp> recvBuf(_size);
+              for (int i=0; i<mpiPtr->nproc(); ++i) {
+                if (i==mpiPtr->rankMaster()) continue;
+                ft.recvf(*mpiPtr, i, recvBuf);
+                ft.waitrecv();
+                sendBuf.insert(sendBuf.end(), recvBuf.begin(), recvBuf.end());
+              }
+              hist.buf2hist(sendBuf);
+              sendBuf = hist.hist2buf(_size);
+              for (int i=1; i<mpiPtr->nproc(); ++i) {
+                ft.sendf(*mpiPtr, sendBuf, i);
+                ft.waitsend();
+              }
+              hist.buf2hist(sendBuf);
+            }
+          }
+
+          /** 
+           * @brief Update histogram of the single process 
+           * @brief Merge histograms from all processes and update the penalty function
+           */
+          double update(Tpair coord) {
+            _cnt++;
+            hist(coord.first, coord.second)++; // increment internal histogram
+            _du = 0;
+            if ((_cnt%_Nupdate)==0) { // if Nupdate'th time
+              exchange();
+              for (auto &m : hist.getMap()) { // update penalty function
+                Tbase::operator()(m.first.first, m.first.second) += std::log(m.second);
+              }
+              double min = Tbase::min()->second;
+              for (auto &m : Tbase::getMap()) {
+                Tbase::operator()(m.first.first, m.first.second) -= min;
+              }
+              assert(hist(coord.first, coord.second)!=0 && "hist_size (>= max # of points in histogram) is set too small.");
+              if (hist(coord.first, coord.second)==0) cout << mpiPtr->rank() << " hist(coord1, coord2)=0\n";
+              _du = std::log(hist(coord.first, coord.second)) - min; // prevents energy drift
+              _du_sum += _du;
+              hist.clear();
+            }
+            return _du;
+          }
+
+          /**
+           * @brief Update histogram of the single process using both the accepted and rejected 
+           * configutations according to the waste_recycling method. DOI:10.1007/3-540-35273-2_4
+           * Merge histograms from all processes and update the penalty function
+           */
+          double update_recycle(std::pair<Tpair,Tpair> coord, double weight, bool rejection) {
+            _cnt++;
+            if (weight < 1) {
+              hist(coord.first.first, coord.first.second) += (1-weight);
+              hist(coord.second.first, coord.second.second) += weight;
+            }
+            else hist(coord.second.first, coord.second.second)++;
+            _du = 0;
+            if ((_cnt%_Nupdate)==0) { // if Nupdate'th time
+              exchange();
+              for (auto &m : hist.getMap()) { // update penalty function
+                Tbase::operator()(m.first.first, m.first.second) += std::log(m.second);
+              }
+              double min = Tbase::min()->second;
+              for (auto &m : Tbase::getMap()) {
+                Tbase::operator()(m.first.first, m.first.second) -= min;
+              }
+              if (!rejection) _du = std::log(hist(coord.second.first, coord.second.second)) - min;
+              else _du = std::log(hist(coord.first.first, coord.first.second)) - min;
+              assert(hist(coord.second.first, coord.second.second)!=0 
+                  && "hist_size (>= max # of points in histogram) is set too small.");
+              _du_sum += _du;
+              hist.clear();
+            }
+            return _du;
+          }
+
+          /*! \brief Save table to disk */
+          void save(const string &filename) {
+            Tbase::save(filename);
+            hist.save(filename+".dist");
+          }
+
+          /*! \brief Translate penalty by a reference value and save it to disk */
+          void save_final(const string &filename, Tcoord a,
+              Tcoord b, Tcoord c, Tcoord d) {
+            double ref_value = - Tbase::ave(a,b,c,d);
+            Tbase::save(filename,1.,ref_value);
+          }
+
+          /*! \brief Load table to disk */
+          void load(const string &filename) {
+            Tbase::load(filename);
+            hist.load(filename+".dist");
+          }
+
+          void test(UnitTest &t) {
+            auto it_max = Tbase::max();
+            auto it_min = Tbase::min();
+            t("Penalty range",it_max->second-it_min->second,2.);
+          }
+
+          string info() {
+            using namespace Faunus::textio;
+            std::ostringstream o;
+            o << header("2D penalty function");
+            if (_cnt/_Nupdate>=1) {
+              char w=25;
+              auto it_max = Tbase::max();
+              auto it_min = Tbase::min();
+              o << textio::pad(SUB,w, "Number of updates") << _cnt/_Nupdate << endl
+                << textio::pad(SUB,w, "Point of lowest penalty") << "(" << it_min->first.first 
+                << ", " << it_min->first.second << ") " << angstrom << endl
+                << textio::pad(SUB,w, "Point of highest penalty") << "(" << it_max->first.first 
+                << ", " << it_max->first.second << ") " << angstrom << endl
+                << textio::pad(SUB,w, "Penalty range") << it_max->second-it_min->second << kT << endl
+                << textio::pad(SUB,w, "Drift compensation") << _du_sum << kT << endl;
+            }
+            return o.str();
+          }
+      };
+#endif
+
+    /**
+      @brief General class for penalty functions along a coordinate
+      @date Malmo, 2011
+
+      This class stores a penalty function, f(x), along a given coordinate, x,
+      of type `Tcoordinate` which could be a distance, angle, volume etc.
+      Initially f(x) is zero for all x.
+      Each time the system visits x the update(x) function should be called
+      so as to add the penalty energy, du. In the energy evaluation, the
+      coordinate x should be associated with the extra energy f(x).
+
+      This will eventually ensure uniform sampling. Example:
+
+      ~~~
+      PenaltyFunction<double> f(0.1,1000,6.0); // 0.1 kT penalty
+      Point masscenter;           // some 3D coordinate...
+      ...
+      f.update(masscenter.z);     // update penalty energy for z component
+      double u = f(masscenter.z); // get accumulated penalty at coordinate (kT)
+      f.save("penalty.dat");      // save to disk
+      ~~~
+
+      In the above example, the penalty energy will be scaled by 0.5 if the
+      sampling along the coordinate is less than 6 kT between the least and
+      most likely position.
+      This threshold check is carried out every 1000th call to `update()`.
+      Note also that when the penalty energy is scaled, so is the threshold
+      (also by a factor of 0.5).
+      */
+    template<typename Tcoord=float>
+      class PenaltyFunction : public Table2D<Tcoord,double> {
+        private:
+          unsigned long long _cnt;
+          int _Ncheck;
+          double _kTthreshold;
+          typedef Table2D<Tcoord,double> Tbase;
+          typedef Table2D<Tcoord,unsigned long long int> Thist;
+          Thist hist;
+          Tcoord _du; //!< penalty energy
+          std::string _log;
+        public:
+          /**
+           * @brief Constructor
+           * @param penalty Penalty energy for each update (kT)
+           * @param Ncheck Check histogram every Nscale'th step
+           *        (put large number for no scaling, default)
+           * @param kTthreshold Half penalty energy once this
+           *        threshold in distribution has been reached
+           * @param res Resolution of the penalty function (default 0.1)
+           */
+          PenaltyFunction(double penalty, int Ncheck=1e9, double kTthreshold=5, Tcoord res=0.1)
+            : Tbase(res, Tbase::XYDATA), hist(res, Thist::HISTOGRAM) {
+              Tbase::name="penalty";
+              _cnt=0;
+              _Ncheck=Ncheck;
+              _kTthreshold=kTthreshold;
+              _du=penalty;
+              assert(Ncheck>0);
+              _log="#   initial penalty energy = "+std::to_string(_du)+"\n";
+            }
+
+          /** @brief Update penalty for coordinate */
+          double update(Tcoord coordinate) {
+            _cnt++;
+            Tbase::operator()(coordinate)+=_du;  // penalize coordinate
+            hist(coordinate)++;                  // increment internal histogram
+            if ((_cnt%_Ncheck)==0) {             // if Ncheck'th time
+              double deltakT=log( hist(hist.maxy()) / double(hist(hist.miny())) );
+              assert(deltakT>0);
+              std::ostringstream o;
+              o << "#   n=" << _cnt << " dkT=" << deltakT;
+              if (deltakT<_kTthreshold) {   // if histogram diff. is smaller than threshold
+                _kTthreshold*=0.5;          // ...downscale threshold
+                scale(0.5);                 // ...and penalty energy
+                o << " update: du=" << _du << " threshold=" << _kTthreshold;
+              }
+              _log += o.str() + "\n";       // save info to log
+            }
+            return _du;
+          }
+          /*! \brief Manually scale penalty energy */
+          void scale(double s) { _du*=s; }
+
+          /*! \brief Save table to disk */
+          void save(const string &filename) {
+            Tbase::save(filename);
+            hist.save(filename+".dist");
+          }
+
+          string info() {
+            return "# Penalty function log:\n" + _log;
+          }
+      };
+
+    template<typename Tx, typename Ty=unsigned long int>
+      class Histogram : public Table2D<Tx,Ty> {
+        public:
+          Histogram(Tx resolution=0.2) : Table2D<Tx,Ty>(resolution, Table2D<Tx,Ty>::HISTOGRAM) {
+            static_assert( std::is_integral<Ty>::value, "Histogram must be of integral type");
+            static_assert( std::is_unsigned<Ty>::value, "Histogram must be unsigned");
+          }
+      };
+
     /*!
      * \brief Radial distribution analysis
      *
@@ -1221,9 +2254,9 @@ namespace Faunus {
     class DipoleAnalysis {
       private:
         Analysis::RadialDistribution<> rdf;
-        Table2D<double,double> kw, mucorr_angle;
-        Table2D<double,Average<double> > mucorr, mucorr_dist; 
-        Histogram<double,unsigned int> HM_x,HM_y,HM_z,HM_x_box,HM_y_box,HM_z_box,HM2,HM2_box;
+        Analysis::Table2D<double,double> kw, mucorr_angle;
+        Analysis::Table2D<double,Average<double> > mucorr, mucorr_dist; 
+        Analysis::Histogram<double,unsigned int> HM_x,HM_y,HM_z,HM_x_box,HM_y_box,HM_z_box,HM2,HM2_box;
         Average<double> M_x,M_y,M_z,M_x_box,M_y_box,M_z_box,M2,M2_box,diel_std, V_t;
         Average<double> mu_abs;
 
@@ -1233,9 +2266,7 @@ namespace Faunus {
 
       public:
         template<class Tspace, class Tinputmap>
-          DipoleAnalysis(const Tspace &spc, Tinputmap &in) : 
-            rdf(0.1),kw(0.1),mucorr_angle(0.1),mucorr(0.1),mucorr_dist(0.1),HM_x(0.1),HM_y(0.1),
-            HM_z(0.1),HM_x_box(0.1),HM_y_box(0.1),HM_z_box(0.1),HM2(0.1),HM2_box(0.1) {
+          DipoleAnalysis(const Tspace &spc, Tinputmap &in) : rdf(0.1),kw(0.1),mucorr_angle(0.1),mucorr(0.1),mucorr_dist(0.1),HM_x(0.1),HM_y(0.1),HM_z(0.1),HM_x_box(0.1),HM_y_box(0.1),HM_z_box(0.1),HM2(0.1),HM2_box(0.1) {
             sampleKW = 0;
             setCutoff(spc.geo.len_half.x());
             N = spc.p.size();
